week:3

DAY1:
problem 1:(lcm gcd)

#include <stdio.h>
int GCD(int A, int B);
int GCD(int A, int B) {
    if(B==0)
        return A;
    else
        return GCD(B, A % B);
}
int main() {
	//code
	long long int t,i,j;
	scanf("%lld",&t);
	for(j=0;j<t;j++)
	{
	    long long int lcm,gcd,a,b;
	    scanf("%lld %lld",&a,&b);
	    gcd=GCD(a,b);
	    lcm=(a*b)/gcd;
	    printf("%lld %lld\n",lcm,gcd);
	}
	return 0;
}

problem 2:(prime numbers)

#include <stdio.h>

int main() {
	//code
	int t,i,j;
	scanf("%d",&t);
	for(i=0;i<t;i++)
	{
	   int a,k;
	   scanf("%d",&a);
	   for(j=2;j<=a;j++)
	   {
	       int flag=0;
	       for(k=j-1;k>=2;k--)
	       {
	           if(j%k==0)
	           {
	               flag=1;
	               break;
	           }
	       }
	       if(flag==0)
	       {
	           printf("%d ",j);
	       }
	   }
	   printf("\n");
	}
	return 0;
}

problem 3:change

#include<stdio.h>
int power(int a,int b);
int power(int a,int b)
{
	int i;
	if(b==0)
	{
		return 1;
	}
	if(b%2==0)
	{
		return power(a*a,b/2);
	}
	else
	{
		return (a*power(a*a,(b-1)/2));
	}
}
int d, x, y,z;
void extendedEuclid(long long int A,long long  int B) {
    if(B == 0) {
        d = A;
        x = 1;
        y = 0;
    }
    else {
        extendedEuclid(m, c%m);
		long long int temp = z;
		z = y;
		y = temp - (c/m)*y;
    }
}
long long int modInverse( long long int c, long long int M)
{
extendedEuclid(c,M);
return (z%M+M)%M;
}
int main()
{
	long long int a,b,c,m,k,p;
	long long int ans;
	scanf("%lld %lld %lld %lld",&a,&b,&c,&m);
	k=power(a,b);
	p=modInverse(c,m);
	ans=(k%m * p%m)%m;
	printf("%lld",ans);
}




DAY 2:
problem 1:

#include<stdio.h>
int gcd(int a, int b);
int gcd(int a, int b)
{
	if(b==0)
	{
		return a;
	}
	else
	{
		return (gcd(b,a%b));
	}
}
int main()
{
	int i,n,count=0;
	scanf("%d",&n);
	for(i=1;i<n;i++)
	{
		int k=gcd(i,n);
		if(k==1)
		{
			count++;
		}
	}
	printf("%d",count);
}

problem 2:

// { Driver Code Starts
#include <bits/stdc++.h> 
using namespace std; 

struct Node
{
    int data;
    struct Node* next;
    
    Node(int x){
        data = x;
        next = NULL;
    }
};
void printList(Node* node) 
{ 
	while (node != NULL) { 
		cout << node->data <<" "; 
		node = node->next; 
	}  
	cout<<"\n";
} 
/* Function to get the middle of the linked list*/
int getMiddle(Node *head);
int main() 
{ 
	int t;
	cin>>t;
	while(t--)
	{
		int n;
		cin>>n;

		int data;
		cin>>data;
		struct Node *head = new Node(data);
		struct Node *tail = head;
		for (int i = 0; i < n-1; ++i)
		{
			cin>>data;
			tail->next = new Node(data);
			tail = tail->next;
		}
		cout<<getMiddle(head)<<endl;
	}
	return 0; 
} 

// } Driver Code Ends


/* Link list Node 
struct Node {
    int data;
    Node* next;
    
    Node(int x){
        data = x;
        next = NULL;
    }
    
}; */

/* Should return data of middle node. If linked list is empty, then  -1*/
int getMiddle(Node *head)
{
   // Your code here
   int k,c=0,c1=0;
   struct Node *p;
   struct Node *q=head;
   p=head;
   while(p!=NULL)
    {
        c++;
        p=p->next;
    }
    k=c/2+1;
    while(q!=NULL)
    {
        c1++;
        if(c1==k)
        {
            return q->data;
        }
        q=q->next;
    }
}

problem :4

// { Driver Code Starts
// C program to detect loop in a linked list
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
using namespace std;

/* Link list Node */
struct Node {
    int data;
    struct Node *next;
    Node(int x) {
        data = x;
        next = NULL;
    }
};

void push(struct Node **head_ref, int new_data) {

    struct Node *new_Node = new Node(new_data);

    new_Node->next = (*head_ref);
    /* move the head to point to the new Node */
    (*head_ref) = new_Node;
}
int detectloop(struct Node *list);
/* Driver program to test above function*/
int main() {
    int t, n, c, x, i;
    cin >> t;
    while (t--) {
        /* Start with the empty list */
        cin >> n;
        struct Node *head = NULL;
        struct Node *temp;
        struct Node *s;
        cin >> x;
        push(&head, x);
        s = head;
        for (i = 1; i < n; i++) {
            cin >> x;
            push(&head, x);
        }
        /* Create a loop for testing */
        cin >> c;
        if (c > 0) {
            c = c - 1;
            temp = head;
            while (c--) temp = temp->next;
            s->next = temp;
        }
        int g = detectloop(head);
        if (g)
            cout << "True\n";
        else
            cout << "False\n";
    }
    return 0;
}
// } Driver Code Ends


/*
struct Node {
    int data;
    struct Node *next;
    Node(int x) {
        data = x;
        next = NULL;
    }

*/
int detectloop(Node *head) {

    struct Node*p=head;
   struct Node*q=head;
   while(p && q &&q->next)
   {
       p=p->next;
       q=q->next->next;
       if(p==q)
       {
           return true;
       }
   }
   return false;
}


problem5:

// { Driver Code Starts
// C program to find n'th Node in linked list
#include <stdio.h>
#include <stdlib.h>
#include<iostream>
using namespace std;

/* Link list Node */
struct Node {
  int data;
  struct Node *next;
  Node(int x) {
    data = x;
    next = NULL;
  }
};


/* Function to get the nth node from the last of a linked list*/
int getNthFromLast(struct Node* head, int n);



/* Driver program to test above function*/
int main()
{
  int T,i,n,l,k;

    cin>>T;

    while(T--){
    struct Node *head = NULL,  *tail = NULL;

        cin>>n>>k;
        int d1;
        cin>>d1;
        head = new Node(d1);
        tail = head;
        for(i=1;i<n;i++)
        {
            cin>>l;
            tail->next = new Node(l);
            tail = tail->next;
        }

    printf("%d", getNthFromLast(head, k));
    cout << endl;
    }
    return 0;
}// } Driver Code Ends


/* struct Node {
  int data;
  struct Node *next;
  Node(int x) {
    data = x;
    next = NULL;
  }
};
*/

/* Should return data of n'th node from the end of linked list.
*  head: head of the linked list
*  n: nth node from end to find
*/
int getNthFromLast(Node *head, int n)
{
       // Your code here
       int c=0,c1=0;
       struct Node*p=head;
       while(p!=NULL)
       {
           c++;
           p=p->next;
       }
       int k=c-n+1;
       struct Node *q=head;
       if(k<1)
       {
           return -1;
       }
       else{
       while(q!=NULL)
       {
           c1++;
           if(c1==k)
           {
               return q->data;
           }
           q=q->next;
       }}
}

